ROLE: Replit.com AI Agent (senior fullstack + QA + security).
PROJECT: SecureLex.ru (Node/Express/TypeScript, pdfkit, audit-engine.ts, pdf-generator.ts).
OBJECTIVE: Довести аудит и PDF‑отчёт до уровня “100/100 реальности”: без симуляций/мокапов/предположений; каждое нарушение = конкретное доказательство; штрафные риски считаются автоматически по мэппингу; PDF выглядит профессионально и максимально подробно; ИИ‑режимы и ключи протестированы и дан чёткий итог.

0) Жёсткие правила (обязательные)
Никаких симуляций результатов в платных отчётах и в PDF: запретить/удалить использование simulateAuditResults, getRandomStatus, getStatusByCategory и любых аналогов, которые дают “рандомные” статусы.​

Никаких предположений в формулировках. Только “обнаружено/не обнаружено” + доказательства.​

Любой warning/failed обязан иметь evidence[] (минимум 1 элемент). Если evidence нет — статус должен быть passed или чек должен вернуть warning с “не удалось проверить” и конкретной причиной (timeout/403/нет HTML), но всё равно с evidence.​

Штрафы: только через заранее заданную таблицу мэппинга “checkId → КоАП (диапазоны)”, с указанием источника нормы (например Consultant/Гарант по КоАП ст. 13.11).​

Суммарные штрафы считать по уникальным aggregationKey, чтобы одно нарушение не суммировалось много раз на разных страницах/эндпоинтах.

1) Диагностика и удаление симуляций (первым делом)
Найди в server/routes.ts (или эквиваленте) блоки: simulateAuditResults, getRandomStatus, getStatusByCategory и любые “веса категорий/рандом”.​

Убери их из платного контура:

Платный контур: POST /api/audits и генерация PDF по реальному runAudit.

Если нужна бесплатная демка — оставь только на публичном эндпоинте (например /api/public/express-check) и запрети PDF по демо‑данным (или ставь watermark “DEMO / симуляция”).

Добавь “охрану” в код: если где-то в платном отчёте остаётся симуляция — выбрасывай ошибку и логируй, чтобы такое не ушло клиенту.

Результат шага: платный аудит = только реальные чекеры.

2) Стандартизировать модель проверок (checkId, evidence, lawBasis)
Ввести стабильный checkId для каждого чекера (не путать с display name).

Расширить AuditCheckResult (или создать AuditCheckResultV2) полями:

checkId: string

lawBasis: Array<{ law: "152"|"149"; article: string; note?: string }>

evidence: string[] (не optional для warning/failed)

aggregationKey: string (для штрафов и дедупликации)

fixSteps: string[] (короткие тех. шаги исправления, реальные)

Обновить существующие чекеры в server/audit-engine.ts, чтобы они возвращали эти поля.​

3) Усилить “реальные проверки” (без догадок)
Для каждого ключевого чекера (как минимум):

HTTPS/редирект HTTP→HTTPS

Security headers: HSTS, CSP, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy

Privacy policy: наличие страницы/ссылки/ключевых блоков (оператор, цели, права субъекта, контакты)

Consent checkbox в формах (по селекторам и текстам согласия)

Cookie banner / consent manager (по HTML/JS признакам + cookies)

Сделать:

Чёткий PASS/FAIL критерий.

evidence из headers/HTML: например “Header ‘strict-transport-security’ отсутствует”, “Не найдено ссылок вида /privacy, /policy”, “В форме найден input[type=checkbox] но без текста согласия” и т.д.

Если сайт не даёт проверить (403/timeout) — это отдельный статус warning с evidence “403 Forbidden” или “Timeout 15s”.

4) Реализовать автоматический расчёт штрафов (penalties-map.ts)
Создай файл server/penalties-map.ts с типами:

SubjectType = citizen | selfEmployed | official | ip | legalEntity

KoapPenalty { koapArticle, koapPart?, subject, minRub, maxRub, confidence, note?, sourceUrl }

PenaltyMappingItem { checkId, title, lawBasis, penalties, aggregationKey }

PENALTY_MAP: Record<checkId, PenaltyMappingItem>

Заполни минимум 10 чеков штрафами.

Источник: КоАП РФ (в первую очередь ст. 13.11) и фиксируй sourceUrl (Consultant/Гарант).​

Правило самозанятого:

самозанятый (НПД) считать как citizen, если не ИП; если ИП на НПД — как ip (в отчёте объяснить).

Реализуй:

attachPenalties(report) — прикрепляет штрафы к каждой ошибке по checkId

calcPenaltyTotals(report) — считает MIN/MAX суммы по каждому subjectType и общую сводку, но дедуплицирует по aggregationKey:

если несколько проверок/страниц дают один и тот же aggregationKey, он учитывается один раз (берём максимальный диапазон из группы или суммируем уникальные подпункты — выбрать строгую, но без дублей стратегию и описать).

5) PDF 2.0 “шикарный” (максимально подробный, но плотный)
Переписать server/pdf-generator.ts так, чтобы:

Убрать огромные пробелы и “воздух”. В текущих PDF заметны повторяющиеся футеры и разрывы/пустоты — исправить layout.​

Параметры:

margin ~20

lineGap 2–3

межсекционный отступ 6–10

таблицы с фиксированной высотой строк

Структура PDF (обязательные разделы):

Титульник + Паспорт аудита (URL, дата, пакет, score, severity, counts).

“Что проверялось” — таблица всех проверок: checkId | название | категория | статус.

“Ошибки и как исправить” — карточки по каждому warning/failed:

найдено + evidence

fixSteps

lawBasis (152/149)

штрафы по всем субъектам

“Матрица соответствия 152/149” — требование → статус → checkId.

“Штрафные риски”:

таблица по уникальным aggregationKey

итоговые суммы MIN/MAX отдельно:

Гражданин

Самозанятый (с правилом)

Должностное лицо

ИП

Юрлицо

“План работ” (0–48ч / 7 дней / 30 дней) со ссылками на checkId/aggregationKey.

Добавить аккуратный header/footer (страница X/Y), без гигантских повторов.​

6) Тест ИИ‑ключей и режимов (после переустановки проекта)
Сейчас ключи могли слететь — нужно дать пользователю чёткий ответ “работает/не работает”.

Проверить env:

GIGACHATAPIKEY

OPENAIAPIKEY​

Прогнать режимы aiMode (через systemsettings и/или env AUDITAIMODE, как реализовано в проекте):

none

gigachatonly

openaionly

hybrid​

Для каждого режима прогнать 2 сценария:

(A) ключ отсутствует (пустая переменная/не задана)

(B) ключ задан корректно

Для каждого прогона:

выполнить POST /api/audits на один и тот же URL,

сохранить JSON результата (в отдельный файл),

скачать PDF,

зафиксировать: был ли вызван провайдер, есть ли summary/recommendations, не было ли падений/500.

Итог: вывести таблицу и однозначный вывод:

какие режимы работают при текущих ключах,

что нужно прописать в .env,

где именно ломается (лог/код) если ломается.

7) Автотесты (минимум)
Добавить unit/интеграционные тесты:

“в платном аудите симуляции запрещены”

“warning/failed → evidence обязателен”

“penalty totals дедуплицируются по aggregationKey”

“aiMode при отсутствии ключей не роняет аудит/сервер”​

DELIVERABLES (что ты обязан выдать в конце)
Список изменённых файлов и коротко “что сделано”.

Примеры 1–2 JSON отчётов (после прогона).

1–2 PDF файла (после прогона).

Таблица по AI‑режимам/ключам и финальный вердикт “ИИ работает/не работает”.

Подтверждение, что симуляции отключены в платном контуре.

END PROMPT.

